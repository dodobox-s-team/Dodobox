from datetime import datetime
from typing import Optional
from sqlalchemy import desc
from api.schemas import db, graphData
from pydantic import BaseModel


class GraphData(BaseModel):
    time: datetime
    graphId: int
    value: float

    @classmethod
    async def add(cls, graphdata: "GraphData") -> "GraphData":
        """
        Add a graphdata to the database.
        The graphdata's id is auto generated by the database.
        The id is suppressed without warning.
        """
        values = graphdata.dict()
        values.pop("graphId")

        query = graphData.insert().values(**values)
        graphdata.graphId = await db.execute(query)

        return graphdata

    @classmethod
    async def get(cls) -> list["GraphData"]:
        """Get data from the database."""
        query = "SELECT time_bucket('1 day', time) AS bucket, FROM graphData GROUP BY bucket"
        return [GraphData(**graphdata) for graphdata in await db.fetch_all(query)]

    @classmethod
    async def get_all(cls) -> list["GraphData"]:
        """Return a list of all the data from the database."""
        return [GraphData(**graphdata) for graphdata in await db.fetch_all(graphData.select())]

    @classmethod
    async def get_latest(cls) -> Optional["GraphData"]:
        """Return a list of the last data from the database."""
        query = graphData.select().order_by(desc(graphData.c.time)).limit(1)
        graphdata = await db.fetch_one(query)
        if graphdata:
            return GraphData(**graphdata)

    @classmethod
    async def delete(cls, graphId: int) -> Optional["GraphData"]:
        """Delete a graphdata and return it. Return None if the data does not exists."""
        query = graphData.delete().where(graphData.c.graphId == graphId).returning(graphData)
        graphdata = await db.fetch_one(query)

        return graphdata
