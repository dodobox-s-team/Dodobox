from datetime import datetime, timedelta
from typing import Optional

from api.schemas import db, graphData
from pydantic import BaseModel, constr


class GraphData(BaseModel):
    time: datetime
    graphId: int
    value: float

    @classmethod
    async def add(cls, graphdata: 'GraphData') -> 'GraphData':
        """
        Add a graphdata to the database.
        The graphdata's id is auto generated by the database.
        The id is suppressed without warning.
        """
        values = graphdata.dict()
        values.pop('id')

        query = graphData.insert().values(**values)
        graphdata.id = await db.execute(query)

        return graphdata

    @classmethod
    async def get(cls) -> Optional['GraphData']:
        """Get data from the database."""
        query = "SELECT time_bucket('1 day', time) AS bucket, FROM graphData GROUP BY bucket"
        graphdata = await db.fetch_all(query)
        if graphdata:
            return GraphData(**graphdata)
    

    @classmethod
    async def update(cls, graphId: int, **kwargs) -> Optional['GraphData']:
        """Update fields of Graphdata."""
        query = graphData.update().where(graphData.c.id == id).values(**kwargs).returning(graphData)
        if graphdata := await db.fetch_one(query):
            return GraphData(**graphdata)

    @classmethod
    async def edit(cls, graphId: int, graphdata: 'GraphData') -> Optional['GraphData']:
        """Edit a graphdata using another graphdata object."""
        graphdata = graphdata.dict()
        graphdata.pop('id')
        return await cls.update(id, **graphdata)

    @classmethod
    async def delete(cls, graphId: int) -> Optional['GraphData']:
        """Delete a graphdata and return it. Return None if the data does not exists."""
        query = graphData.delete().where(graphData.c.id == id).returning(graphData)
        graphdata = await db.fetch_one(query)

        return graphdata