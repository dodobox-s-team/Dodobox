from typing import Optional

from api.schemas import db, graphs
from pydantic import BaseModel, constr


class Graph(BaseModel):
    id: Optional[int]
    deviceId: Optional[int]
    name: constr(max_length=64)
    axisLabel: constr(max_length=64)

    @classmethod
    async def add(cls, graph: 'Graph') -> 'Graph':
        """
        Add a graph to the database.
        The graph's id is auto generated by the database.
        The id is suppressed without warning.
        """
        values = graph.dict()
        values.pop('id')

        query = graphs.insert().values(**values)
        graph.id = await db.execute(query)

        return graph
    
    @classmethod
    async def get (cls, id: int) -> Optional['Graph']:
        """Get a graph from the database from its id."""
        query = graphs.select().where(graphs.c.id == id)
        graph = await db.fetch_one(query)
        if graph:
            return Graph(**graph)

    @classmethod
    async def get_all (cls) -> list['Graph']:
        """Return a list of all graphs from the database.""" 
           return [Graph(**graph) for graph in await db.fetch_all(graphs.select())]

    @classmethod
    async def update (cls, id: int, **kwargs) -> Optional['Graph']:
        """Update fields of a graph."""
        query = graphs.update().where(graphs.c.id == id).values(**kwargs).returning(graphs)
        if graph := await db.fetch_one(query):
            return Graph(**graph)

    @classmethod
    async def edit (cls, id: int, graph: 'Graph') -> 'Graph':
        """Edit a graph using another device object."""
        graph = graph.dict()
        graph.pop('id')
        return await cls.update(id, **graph)
    @classmethod
    async def delete (cls, id: int) -> 'Graph':
        """Delete a graph and return it. Return None if the graph does not exists."""
        query = graphs.delete().where(graphs.c.id == id).returning(graphs)
        graph = await db.fetch_one(query)

        return graph

        